---
title: Proyecto Análisis Exploratorio de Datos 2023
author:
  - name: Javier Hinarejos Albero
    affil: 1, \dagger
  - name: Samuel Ortega Mediavilla
    affil: 1, \dagger, *
affiliation:
  - num: 1
    address: |
      Universitat de València - 
      Escuela Técnica Superior de Ingeniería
      Avenida de la Universitat s/n 46100 Burjassot. Valencia. España
# author citation list in chicago format
authorcitation: |
  Hinarejos, J.; Ortega, S.
# firstnote to eighthnote
firstnote: |
  These authors contributed equally to this work.
correspondence: |
  saorme@alumni.uv.es.
# document options
journal: notspecified
type: article
status: submit
# front matter
simplesummary: |
  A Simple summary goes here.
abstract: |
  A single paragraph of about 200 words maximum. For research articles, 
  abstracts should give a pertinent overview of the work. We strongly encourage
  authors to use the following style of structured abstracts, but without 
  headings: 1) Background: Place the question addressed in a broad context and
  highlight the purpose of the study; 2) Methods: Describe briefly the main
  methods or treatments applied; 3) Results: Summarize the article's main 
  findings; and 4) Conclusion: Indicate the main conclusions or interpretations. 
  The abstract should be an objective representation of the article, it must not 
  contain results which are not presented and substantiated in the main text and 
  should not exaggerate the main conclusions.
# back matter
keywords: |
  keyword 1; keyword 2; keyword 3 (list three to ten pertinent keywords specific 
  to the article, yet reasonably common within the subject discipline.).
acknowledgement: |
  All sources of funding of the study should be disclosed. Please clearly 
  indicate grants that you have received in support of your research work. 
  Clearly state if you received funds for covering the costs to publish in open 
  access.
authorcontributions: |
  For research articles with several authors, a short paragraph specifying their 
  individual contributions must be provided. The following statements should be 
  used ``X.X. and Y.Y. conceive and designed the experiments; X.X. performed the 
  experiments; X.X. and Y.Y. analyzed the data; W.W. contributed 
  reagents/materials/analysis tools; Y.Y. wrote the paper.'' Authorship must be
  limited to those who have contributed substantially to the work reported.
funding: |
  This research received no external funding.
institutionalreview: |
  In this section, you should add the Institutional Review Board Statement and 
  approval number, if relevant to your study. You might choose to exclude 
  this statement if the study did not require ethical approval. Please note 
  that the Editorial Office might ask you for further information. Please add 
  “The study was conducted in accordance with the Declaration of Helsinki, 
  and approved by the Institutional Review Board (or Ethics Committee) of 
  NAME OF INSTITUTE (protocol code XXX and date of approval).” for studies 
  involving humans. OR “The animal study protocol was approved by the 
  Institutional Review Board (or Ethics Committee) of NAME OF INSTITUTE 
  (protocol code XXX and date of approval).” for studies involving animals. 
  OR “Ethical review and approval were waived for this study due to REASON 
  (please provide a detailed justification).” OR “Not applicable” for
   studies not involving humans or animals.
informedconsent: |
  Any research article describing a study involving humans should contain this 
  statement. Please add ``Informed consent was obtained from all subjects 
  involved in the study.'' OR ``Patient consent was waived due to REASON 
  (please provide a detailed justification).'' OR ``Not applicable'' for 
  studies not involving humans. You might also choose to exclude this statement 
  if the study did not involve humans.
  
  Written informed consent for publication must be obtained from participating 
  patients who can be identified (including by the patients themselves). Please 
  state ``Written informed consent has been obtained from the patient(s) to 
  publish this paper'' if applicable.
dataavailability: |
  We encourage all authors of articles published in MDPI journals to share 
  their research data. In this section, please provide details regarding where 
  data supporting reported results can be found, including links to publicly 
  archived datasets analyzed or generated during the study. Where no new data 
  were created, or where data is unavailable due to privacy or ethical 
  re-strictions, a statement is still required. Suggested Data Availability 
  Statements are available in section “MDPI Research Data Policies” at 
  \url{https://www.mdpi.com/ethics}.
conflictsofinterest: |
  Declare conflicts of interest or state 'The authors declare no conflict of 
  interest.' Authors must identify and declare any personal circumstances or
  interest that may be perceived as inappropriately influencing the
  representation or interpretation of reported research results. Any role of the
  funding sponsors in the design of the study; in the collection, analyses or 
  interpretation of data in the writing of the manuscript, or in the decision to 
  publish the results must be declared in this section. If there is no role, 
  please state 'The founding sponsors had no role in the design of the study; 
  in the collection, analyses, or interpretation of data; in the writing of the 
  manuscript, an in the decision to publish the results'.
sampleavailability: |
  Samples of the compounds ...... are available from the authors.
supplementary: |
 The following supporting information can be downloaded at:  
 \linksupplementary{s1}, Figure S1: title; Table S1: title; Video S1: title.
abbreviations:
  - short: INE
    long: Instituto Nacional de Estadística
bibliography: mybibfile.bib
appendix: appendix.tex
endnotes: false
output: 
  rticles::mdpi_article:
    extra_dependencies: longtable
---

```{r setup, cache = F, echo = F, message = F, warning = F, tidy = F}
# Configuración general de chunks
if (!require(knitr)) {
  install.packages("knitr")
  library(knitr)
}
options(width = 100)
knitr::opts_chunk$set(echo = T, message = T, error = F, warning = F, comment = NA, dpi = 100, tidy = T, cache.path = '.cache/', fig.path = './figure/', include = T)
```

```{r packages, message = T, include = T, echo = T}
# Carga de paquetes necesarios con pacman
if (!require(pacman)) {
  install.packages("pacman")
  library(pacman)
}
pacman::p_load(kableExtra, readxl)
```

# Datos seleccionados

Hemos escogido los datos de variaciones residenciales en 2021 del INE. Estos datos están disponibles en el siguiente enlace <https://www.ine.es/dyngs/INEbase/es/operacion.htm?c=Estadistica_C&cid=1254736177013&menu=resultados&secc=1254736195469&idp=1254734710990#!tabs-1254736195469>.

Adicionalmente, hemos empleado la relación de municipios de 2021 <https://www.ine.es/dyngs/INEbase/es/operacion.htm?c=Estadistica_C&cid=1254736177013&menu=resultados&secc=1254736195469&idp=1254734710990#!tabs-1254736195469>.

# Previsualización de los datos

En el fichero principal de datos `md_EVR_2021.txt`, observamos que cada registro contiene una cadena de caracteres de longitud fija. Su interpretación viene detallada en el fichero adicional `dr_EVR_2021.xlsx`.

```{r preview}
raw_data_preview <- readLines('./data/md_EVR_2021.txt', n = 3)
kable(raw_data_preview)
```

```{r def-functions}
load_excel_dicts <- function(excel_dict_file, main_sheet = "Diseño") {
  
  sheet_names <- excel_sheets(excel_dict_file)
  sheet_list <- list()
  
  for (sheet_name in sheet_names[sheet_names != main_sheet]) {
    
    sheet_data <- read_excel(excel_dict_file, sheet = sheet_name,
                             col_names = FALSE)
    
    # Añadimos el nombre del diccionario del anexo
    if (sheet_name == "Anexo - Lista de países") {
      sheet_data[4, 1] <- "T_MUNI"
    }
    sheet_list[[sheet_name]] <- sheet_data
  }
  return(sheet_list)
}

create_dict_list <- function(vars_table) {
  
  # Cogemos la información sobre los diccionarios
  dict_df <- vars_table[c("Diccionario de la variable", "Diccionario ubicado en la hoja…")]
  colnames(dict_df) <- c("name", "sheet")
  dict_df <- unique( dict_df[complete.cases(dict_df), ] )
  
  # Creamos la lista con la información de cada diccionario
  dict_list <- list()
  for (idx in 1 : nrow(dict_df)) {
    
    related_vars <- vars_table$Variable[
      (vars_table$`Diccionario de la variable` == dict_df$name[idx]) &
      (!is.na(vars_table$`Diccionario de la variable`))]
    
    dict_list[[ dict_df$name[idx] ]] <- list(sheet = dict_df$sheet[idx],
                                             vars = related_vars,
                                             is_obs = FALSE)
  }
  
  # Añadimos la información del diccionario indicado en observaciones
  related_vars <- vars_table$Variable[!is.na(vars_table$Observaciones)]
  dict_list[["T_MUNI"]] <- list(sheet = "Anexo - Lista de países",
                                vars = related_vars,
                                is_obs = TRUE)
  return(dict_list)
}

get_dict_from_sheets <- function(dict_list, sheet_list, aditional_data) {
  
  # Inicializamos la tabla-diccionario
  col_names <- c("name", "code", "value")
  dict_info <- data.frame(matrix(nrow = 0, ncol = length(col_names)))
  colnames(dict_info) <- col_names
  
  # Buscamos cada diccionario
  for (sheet_name in names(sheet_list)) {
    
    sheet_table <- sheet_list[[sheet_name]]
    
    for(dict_name in names(dict_list)) {
      
      if (dict_list[[dict_name]]$sheet == sheet_name) {
        
        dict_start <- which(sheet_table == dict_name, arr.ind = TRUE)
        dict_row_end <- dict_start[1]
        while ( (dict_row_end + 1) <= nrow(sheet_table) ) {
          
          if ( is.na(sheet_table[[(dict_row_end + 1), dict_start[2]]]) ) {
            break
          }
          dict_row_end <- dict_row_end + 1
        }
        # Creamos una tabla con el diccionario
        dict_df <- sheet_table[
                               (dict_start[1] + 2) : dict_row_end,
                               dict_start[2] : (dict_start[2] + 1)]
        
        if (dict_list[[dict_name]]$is_obs) {
          aditional_data <- prepare_aditional_data(aditional_data, names(dict_df))
          dict_df <- rbind(dict_df, aditional_data)
        }
        dict_df <- cbind(dict_name, dict_df)
        
        # Añadimos cada diccionario a la tabla
        colnames(dict_df) <- colnames(dict_info)
        dict_info <- rbind(dict_info, dict_df)
      }
    }
  }
  return(dict_info)
}

prepare_aditional_data <- function(aditional_data, col_names) {
  
  if (any(colnames(aditional_data) != col_names)) {
    
    aditional_data <- aditional_data[c("CMUN", "NOMBRE")]
    colnames(aditional_data) <- col_names
  }
  return(aditional_data)
}

apply_dict_to_data <- function(data_df, dict_info, dict_list) {
  
  for (dict_name in names(dict_list)) {
    
    this_dict <- dict_info[dict_info$name == dict_name, ]
    
    for (var_name in dict_list[[dict_name]]$vars) {
      
      data_df[var_name] <- apply_dict_to_variable(data_df[[var_name]], this_dict)
    }
  }
  return(data_df)
}

apply_dict_to_variable <- function(codes, dict) {
  
  values <- factor(
    x = codes,
    levels = dict$code,
    labels = dict$value)
  return(values)
}
```

# Lectura de los ficheros

```{r}
data_file <- "./data/md_EVR_2021.txt"
excel_dict_file <- "./data/dr_EVR_2021.xlsx"
main_sheet <- "Diseño"
municipios_file <- "./data/diccionario21.xlsx"

raw_data <- readLines(data_file, encoding = "UTF-8")

vars_table <- read_excel(excel_dict_file, sheet = main_sheet,
                         range = "A2:J19", col_names = TRUE)
```

# Preprocesado

## Limpieza de longitud incorrecta

```{r}
entry_length <- vars_table$Longitud[vars_table$Variable == "TOTAL"]

filtered_raw_data <- raw_data[nchar(raw_data) == entry_length]

# No necesitamos la última entrada para nada más
vars_table <- vars_table[vars_table$Variable != "TOTAL", ]
```

## Creación del dataframe

```{r}
splitted_raw_data <- list()

for (var_idx in 1:nrow(vars_table)) {
  
  # Dividimos cada entrada según las posiciones y longitudes del excel
  aux <- substr(
    filtered_raw_data,
    vars_table$Posición[var_idx],
    vars_table$Posición[var_idx] + vars_table$Longitud[var_idx] - 1)
  
  splitted_raw_data[[vars_table$Variable[var_idx]]] <- aux
}

raw_data_df <- data.frame(splitted_raw_data)
```

## Obtención de los diccionarios

```{r}
sheet_list <- load_excel_dicts(excel_dict_file)
municipios_data <- read_excel(municipios_file, skip = 1,
                                  col_names = TRUE)

dict_list <- create_dict_list(vars_table)
dict_info <- get_dict_from_sheets(dict_list, sheet_list, municipios_data)
```

## Interpretación de los códigos de las variables

Leemos los diccionarios de las variables del excel y sustituimos el código por la descripción.

```{r}
data_df <- apply_dict_to_data(raw_data_df, dict_info, dict_list)
```

```{r}
# Automatizar -> check_na_procedence
var_name <- "TAMUNACI"
unique(raw_data_df[is.na(data_df[[var_name]]), var_name])
colSums(is.na(data_df))
```

A continuación, vamos a cambiar el tipo de las variables para tenerlas en el formato adecuado. Para ello, en primer lugar, escribimos un fichero csv con el formato actual de los datos.

```{r}
write.csv(data_df, './data/data.csv',row.names = FALSE)
```

Seguidamente, mediante el argumento col_types de read_csv cambiamos el formato de las columnas al formato deseado.
```{r}
library(readr)
data <- read_csv("./data/data.csv", col_types = cols(EDAD = col_number(), 
    MESNAC = col_number(), ANONAC = col_number(), 
    MESVAR = col_number(), ANOVAR = col_number()))
```
