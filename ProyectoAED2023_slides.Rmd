---
title: "Estudio de las variaciones residenciales en España en 2021"
author: Javier Hinarejos & Samuel Ortega
date: 13-11-2023
output:
  ioslides_presentation:
    number_sections: true
    widescreen: true
    logo: logo.jpg
    smaller: true
    df_print: paged
---

```{css style-opts, echo=FALSE}

.title-slide hgroup h1 {
  font-size: 50px;
  letter-spacing: 1px;
}

.gdbar img {
  width: 500px !important;
  height: 100px !important;
  margin: 8px 8px;
}

.gdbar {
  width: 550px !important;
  height: 120px !important;
}

slides > slide:not(.nobackground):before {
  width: 300px;
  height: 60px;
  background-size: 300px 60px;
}
```

```{r setup, include=FALSE}
base::options(width = 50, digits = 3)
knitr::opts_chunk$set(echo = F, message = T, error = F, warning = F, comment = NA, dpi = 100, tidy = T, cache.path = '.cache/', fig.path = './figure/', include = T)

if (!require(pacman)) {
  install.packages("pacman")
  library(pacman)
}
pacman::p_load(imager, readxl, kableExtra)
source("ProyectoAED2023_library.R")
```

# Inspección de los datos

## Obtención de los datos {#obt-datos}

<style>
  #obt-datos > p {      
    margin-top: -30px;     
  }
  </style>
  
Base de microdatos del INE:

 - Variaciones residenciales (2021): [https://go.uv.es/saorme/ine-var-res-2021](https://go.uv.es/saorme/ine-var-res-2021).
 - Diccionario de municipios (2021): [https://go.uv.es/saorme/ine-muni-2021](https://go.uv.es/saorme/ine-muni-2021).

```{r ine-img, fig.height = 4, fig.align="center"}
myimg <- load.image("./figure/ine.png")
par(mar = c(0, 0, 1, 0))
plot(myimg, axes = FALSE)
```


## Previsualización del fichero principal

La información está almacenada en el fichero en filas de longitud fija.

<font size="1">
```{r preview}
raw_data_preview <- readLines('./data/md_EVR_2021.txt', n = 3)
preview_df <- data.frame(linea = 1:length(raw_data_preview), contenido = raw_data_preview)
preview_df
```
<font size="1">

Interpretamos la información con el fichero de metadatos.

<font size="1">
```{r metadatos}
excel_dict_file <- "./data/dr_EVR_2021.xlsx"
metadata <- read_excel(excel_dict_file, sheet = "Diseño",
                         range = "A2:J19", col_names = TRUE)

metadata
```
<font size="1">

## Preprocesado

Como primera comprobación, nos aseguramos de que todas las entradas de los datos crudos tienen la longitud adecuada. Este valor está definido en la tabla de metadatos.

```{r}
data_file <- "./data/md_EVR_2021.txt"
raw_data <- readLines(data_file, encoding = "UTF-8")
entry_length <- metadata$Longitud[metadata$Variable == "TOTAL"]

filtered_raw_data <- raw_data[nchar(raw_data) == entry_length]

# No necesitamos la última entrada para nada más
vars_table <- metadata[metadata$Variable != "TOTAL", ]

vars_table
```


## Creación del dataframe

Una vez nos hemos asegurado de que todas las entradas tienen la longitud correcta, dividimos cada una de ellas en distintas variables de un `data.frame` a partir de las posiciones y longitudes definidas en los metadatos.

```{r split-data}
raw_data_df <- split_raw_data(filtered_raw_data, vars_table)
raw_data_df
```

## Obtención de los diccionarios

A continuación, extraemos de los ficheros adicionales la información necesaria para interpretar los códigos de los datos crudos. Generamos dos variables:

 - `dict_list`
 
 - `dict_info`

```{r get-dicts}
excel_dict_file <- "./data/dr_EVR_2021.xlsx"
sheet_list <- load_excel_dicts(excel_dict_file)
main_sheet <- "Diseño"
municipios_file <- "./data/diccionario21.xlsx"

municipios_data <- read_excel(municipios_file, skip = 1,
                                  col_names = TRUE)
dict_list <- create_dict_list(vars_table)
dict_info <- get_dict_from_sheets(dict_list, sheet_list, municipios_data)
```

## Conversión variables

El último paso del preprocesado del dataset es la conversión de las variables para al formato adecuado. Está indicado en los metadatos, donde figuran dos tipos:

 - N: numérico -> `numeric`
 - A: alfanumérico -> `factor`

```{r convert-num}
data_df <- apply_dict_to_data(raw_data_df, dict_info, dict_list)
data_df <- convert_numeric_vars(data_df, vars_table)
```

# Análisis de las variables

## Resumen del dataset

En primer lugar, realizamos un `summary()` para obtener la información esencial de cada variable.

Seguidamente, observamos el tipo de cada variable para confirmar que estén en el formato adecuado empleando la función `str()`.

```{r str-data}
str(data_df)
```

Eliminamos las siguientes variables de nuestro conjunto de datos:

 - **MESNAC**

 - **ANOVAR**
 
 - **MESVAR**
 
 Creamos nuevas variables que contienen las comunidades autónomas.


## Datos faltantes

En los resúmenes mostrados podemos observamos que las variables de municipio y tamaño contienen numerosos valores faltantes. Además, en algunas de las variables categóricas, aparecen niveles cuyo significado es equivalente a un dato faltante de cara al análisis: "No Consta", "Other", "Baja por Caducidad".

# Análisis Univariante

## Numéricas

```{r}
plot_file <- "./figure/boxplot_edad.jpg"
img <- load.image(plot_file)
par(mar = c(0, 0, 0, 0))
plot(img, axes = FALSE)
```

```{r}
par(mfrow=c(1,2))
plot_file <- "./figure/descdist_edad.jpg"
img <- load.image(plot_file)
par(mar = c(0, 0, 0, 0))
plot(img, axes = FALSE)

plot_file <- "./figure/descdist_mesvar.jpg"
img <- load.image(plot_file)
par(mar = c(0, 0, 0, 0))
plot(img, axes = FALSE)
```
## Aproximación normal

```{r qqplot}
plot_file <- "./figure/qqplot_edad.jpg"
img <- load.image(plot_file)
par(mar = c(0, 0, 0, 0))
plot(img, axes = FALSE)
```

## Movimiento entre comunidades

```{r}
plot_file <- "./figure/barplot_diffs.jpg"
img <- load.image(plot_file)
par(mar = c(0, 0, 0, 0))
plot(img, axes = FALSE)
```

## Análisis bivariante

### Numérica - Numérica

La variable **ANONAC** debería tener una gran correlación con la variable **EDAD**.

```{r bivar-anonac-edad1}
plot_file <- "./figure/pairs_anonac_edad.jpg"
img <- load.image(plot_file)
par(mar = c(0, 0, 0, 0))
plot(img, axes = FALSE)
```

$EDAD = 2021 - ANONAC$

### Numéricas- Categóricas

```{r hist-num-cat}
plot_file <- "./figure/hist_edad_sexo.jpg"
img <- load.image(plot_file)
par(mar = c(0, 0, 0, 0))
plot(img, axes = FALSE)
```

```{r boxplot-sexo}
mujeres <- filter(data_df, SEXO == "Mujer")
hombres <- filter(data_df, SEXO=='Hombre')

t.test(mujeres$EDAD,hombres$EDAD)

plot_file <- "./figure/boxplot_edad_sexo.jpg"
img <- load.image(plot_file)
par(mar = c(0, 0, 0, 0))
plot(img, axes = FALSE)
```

### Categóricas - Categóricas

Para seguir con el estudio del éxodo rural, podemos representar la relación entre el tamaño de los municipios de alta y de baja en un mosaico. Por limpieza, hemos recodificado las categorías de tamaño de la siguiente manera:

| Código en el mosaico | Descripción |
| -:- | -:- |
| tam_1 | Municipio no capital hasta 10.000 habitantes |
| tam_2 | Municipio no capital de 10.001 a 20.000 |
| tam_3 | Municipio no capital de 20.001 a 50.000 |
| tam_4 | Municipio no capital de 50.001 a 100.000 |
| tam_5 | Municipio no capital  de más de 100.000 |
| capital | Municipio capital de provincia |

Para complementar este análisis, transformamos nuestros datos a fin de obtener un `data.frame` con la siguiente estructura:

 - **MUNI**: contiene todos los valores únicos de las variables **MUNIALTA** y **MUNIBAJA**.

 - **TAMU**: valor correspondiente de **TAMUALTA** / **TAMUBAJA**.
 
 - **isCAPITAL**: valor lógico que indica si el municipio es capital.
 
 - **EDAD**: media de la edad de los desplazados desde ó hasta cada municipio.
 
 - **MES**: moda del mes en el que se producen los movimientos desde ó hasta cada municipio.
 
 - **nBAJAS**: número de bajas en cada municipio.
 
 - **nALTAS**: número de bajas en cada municipio.
 
Las variables adicionales **nTOTAL** y **nNETO** son la suma y la diferencia de las últimas dos variables listadas.

## Análisis interactivo: mapas

### Características

Se usa el test Chi-cuadrado. Este test supone una hipótesis de partida $H_0$ (Son independientes) y dependiendo del resultado del
test, se acepta o no:

p<0.05: Rechazamos hipótesis
p \(\geq\) 0.05: Aceptamos Ho

```{r chisq-comu}
tablacontingencia1 <- table(data_df$COMUBAJA, data_df$COMUALTA)
chitest1 <- chisq.test(tablacontingencia1, correct = FALSE)
print(chitest1)
```

## Análisis de outliers

```{r}
outliers <- detect_outliers(data_df$EDAD)
outliers
```



